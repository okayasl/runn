// Multi-class classification
// One-hot encoding problem with 3 classes.
// predict 1,0,0 if all input elements are same
// predict 0,1,0 if only two of the input elements are same
// predict 0,0,1 if none of the input elements are same

use runn::matrix::DenseMatrix;

pub(crate) fn training_inputs() -> DenseMatrix {
    let inps = vec![
        5.0, 4.0, 4.0, 2.0, 5.0, 5.0, 5.0, 5.0, 5.0, 6.0, 6.0, 6.0, 1.0, 6.0, 2.0, 1.0, 3.0, 6.0, 5.0, 5.0, 5.0, 3.0,
        2.0, 6.0, 4.0, 9.0, 4.0, 0.0, 0.0, 0.0, 2.0, 6.0, 4.0, 2.0, 6.0, 2.0, 8.0, 8.0, 8.0, 2.0, 7.0, 2.0, 0.0, 0.0,
        0.0, 8.0, 8.0, 8.0, 6.0, 6.0, 6.0, 1.0, 1.0, 1.0, 1.0, 3.0, 3.0, 2.0, 2.0, 2.0, 6.0, 7.0, 7.0, 8.0, 4.0, 7.0,
        4.0, 4.0, 4.0, 4.0, 7.0, 5.0, 1.0, 2.0, 8.0, 1.0, 9.0, 3.0, 0.0, 4.0, 0.0, 3.0, 7.0, 7.0, 2.0, 5.0, 1.0, 8.0,
        1.0, 1.0, 4.0, 9.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 4.0, 4.0, 4.0, 5.0, 5.0, 5.0, 7.0, 0.0, 0.0, 6.0, 6.0,
        6.0, 7.0, 1.0, 4.0, 2.0, 2.0, 2.0, 8.0, 7.0, 0.0, 9.0, 2.0, 2.0, 7.0, 7.0, 7.0, 0.0, 0.0, 0.0, 6.0, 5.0, 5.0,
        4.0, 4.0, 4.0, 3.0, 1.0, 6.0, 5.0, 1.0, 5.0, 2.0, 2.0, 2.0, 8.0, 1.0, 9.0, 5.0, 8.0, 8.0, 0.0, 6.0, 1.0, 3.0,
        6.0, 6.0, 1.0, 4.0, 7.0, 6.0, 6.0, 6.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 6.0, 3.0, 0.0, 4.0, 4.0, 4.0, 9.0, 9.0,
        9.0, 1.0, 3.0, 0.0, 0.0, 5.0, 5.0, 6.0, 5.0, 5.0, 0.0, 5.0, 5.0, 0.0, 1.0, 1.0, 5.0, 1.0, 7.0, 7.0, 6.0, 7.0,
        2.0, 0.0, 7.0, 3.0, 6.0, 0.0, 8.0, 5.0, 9.0, 0.0, 4.0, 0.0, 9.0, 8.0, 9.0, 4.0, 7.0, 6.0, 2.0, 2.0, 2.0, 0.0,
        0.0, 0.0, 1.0, 6.0, 7.0, 8.0, 3.0, 9.0, 5.0, 1.0, 0.0, 8.0, 9.0, 9.0, 3.0, 3.0, 3.0, 9.0, 7.0, 1.0, 9.0, 7.0,
        5.0, 7.0, 7.0, 7.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 8.0, 3.0, 3.0, 9.0, 9.0, 9.0, 2.0, 6.0, 2.0, 4.0, 2.0, 8.0,
        5.0, 9.0, 9.0, 3.0, 9.0, 7.0, 7.0, 8.0, 4.0, 9.0, 8.0, 3.0, 7.0, 3.0, 9.0, 7.0, 2.0, 7.0, 5.0, 5.0, 5.0, 7.0,
        2.0, 7.0, 0.0, 6.0, 6.0, 9.0, 1.0, 7.0, 9.0, 6.0, 6.0, 6.0, 9.0, 9.0, 2.0, 6.0, 9.0, 9.0, 8.0, 8.0, 7.0, 4.0,
        5.0, 0.0, 5.0, 7.0, 2.0, 2.0, 2.0, 7.0, 3.0, 9.0, 6.0, 6.0, 6.0, 7.0, 7.0, 7.0, 1.0, 1.0, 1.0, 7.0, 7.0, 7.0,
        2.0, 2.0, 2.0, 8.0, 6.0, 6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 8.0, 1.0, 0.0, 7.0, 7.0, 7.0, 4.0, 2.0, 4.0, 9.0,
        9.0, 9.0, 2.0, 2.0, 2.0, 6.0, 0.0, 5.0, 3.0, 7.0, 8.0, 6.0, 6.0, 6.0, 7.0, 2.0, 0.0, 1.0, 4.0, 8.0, 5.0, 0.0,
        5.0, 1.0, 6.0, 6.0, 9.0, 3.0, 3.0, 3.0, 5.0, 2.0, 3.0, 2.0, 4.0, 8.0, 8.0, 8.0, 9.0, 6.0, 6.0, 6.0, 6.0, 6.0,
        3.0, 8.0, 8.0, 5.0, 2.0, 9.0, 9.0, 8.0, 9.0, 2.0, 0.0, 0.0, 6.0, 8.0, 8.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 5.0,
        4.0, 4.0, 4.0, 0.0, 4.0, 0.0, 2.0, 0.0, 7.0, 6.0, 3.0, 1.0, 8.0, 8.0, 3.0, 1.0, 3.0, 6.0, 7.0, 4.0, 4.0, 4.0,
        4.0, 5.0, 6.0, 7.0, 1.0, 1.0, 1.0, 4.0, 5.0, 2.0, 7.0, 7.0, 7.0, 2.0, 5.0, 5.0, 7.0, 8.0, 8.0, 6.0, 5.0, 0.0,
        2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 3.0, 8.0, 7.0, 9.0, 9.0, 9.0, 7.0, 7.0, 7.0, 3.0, 0.0, 6.0, 9.0, 4.0, 7.0, 0.0,
        1.0, 0.0, 1.0, 3.0, 1.0, 5.0, 1.0, 3.0, 1.0, 6.0, 6.0, 9.0, 6.0, 3.0, 1.0, 1.0, 1.0, 4.0, 4.0, 4.0, 1.0, 6.0,
        6.0, 1.0, 2.0, 3.0, 9.0, 4.0, 4.0, 2.0, 2.0, 2.0, 9.0, 5.0, 5.0, 9.0, 8.0, 0.0, 1.0, 9.0, 1.0, 8.0, 5.0, 9.0,
        3.0, 3.0, 3.0, 5.0, 9.0, 2.0, 5.0, 8.0, 5.0, 7.0, 3.0, 3.0, 1.0, 3.0, 3.0, 0.0, 7.0, 9.0, 0.0, 0.0, 0.0, 2.0,
        5.0, 0.0, 7.0, 9.0, 1.0, 4.0, 5.0, 5.0, 8.0, 1.0, 1.0, 9.0, 8.0, 9.0, 5.0, 5.0, 5.0, 3.0, 1.0, 3.0, 1.0, 3.0,
        8.0, 2.0, 4.0, 6.0, 5.0, 5.0, 5.0, 1.0, 0.0, 0.0, 2.0, 2.0, 2.0, 8.0, 4.0, 4.0, 6.0, 6.0, 6.0, 7.0, 3.0, 9.0,
    ];
    let inp_size = 3;
    let inps_row = inps.len() / inp_size;
    DenseMatrix::new(inps_row, inp_size, &inps)
}

pub(crate) fn training_targets() -> DenseMatrix {
    let tar = vec![
        0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
        0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,
        0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
        1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
        1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
    ];

    let targ_size = 3;
    let targ_row = tar.len() / targ_size;
    DenseMatrix::new(targ_row, targ_size, &tar)
}

pub(crate) fn validation_inputs() -> DenseMatrix {
    let inps = vec![
        1.0, 6.0, 5.0, 0.0, 8.0, 9.0, 7.0, 6.0, 6.0, 0.0, 9.0, 9.0, 0.0, 7.0, 0.0, 8.0, 3.0, 8.0, 4.0, 9.0, 5.0, 7.0,
        5.0, 6.0, 6.0, 5.0, 5.0, 0.0, 9.0, 8.0, 3.0, 0.0, 3.0, 2.0, 5.0, 7.0, 1.0, 1.0, 1.0, 6.0, 2.0, 0.0, 7.0, 5.0,
        5.0, 0.0, 2.0, 1.0, 4.0, 9.0, 3.0, 7.0, 9.0, 7.0, 0.0, 0.0, 0.0, 3.0, 5.0, 7.0, 5.0, 4.0, 4.0, 4.0, 4.0, 4.0,
        2.0, 2.0, 2.0, 2.0, 0.0, 2.0, 4.0, 4.0, 4.0, 6.0, 6.0, 6.0, 9.0, 9.0, 9.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 7.0,
        7.0, 7.0,
    ];

    let inp_size = 3;
    let inps_row = inps.len() / inp_size;
    DenseMatrix::new(inps_row, inp_size, &inps)
}

pub(crate) fn validation_targets() -> DenseMatrix {
    let tar = vec![
        0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
        0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0,
        0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,
        0.0, 0.0,
    ];

    let targ_size = 3;
    let targ_row = tar.len() / targ_size;
    DenseMatrix::new(targ_row, targ_size, &tar)
}
