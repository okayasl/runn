// This file is @generated by prost-build.
/// Serialization format for histogram module in
/// tsl/lib/histogram/histogram.h
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramProto {
    #[prost(double, tag = "1")]
    pub min: f64,
    #[prost(double, tag = "2")]
    pub max: f64,
    #[prost(double, tag = "3")]
    pub num: f64,
    #[prost(double, tag = "4")]
    pub sum: f64,
    #[prost(double, tag = "5")]
    pub sum_squares: f64,
    /// Parallel arrays encoding the bucket boundaries and the bucket values.
    /// bucket(i) is the count for the bucket i.  The range for
    /// a bucket is:
    ///    i == 0:  -DBL_MAX .. bucket_limit(0)
    ///    i != 0:  bucket_limit(i-1) .. bucket_limit(i)
    #[prost(double, repeated, tag = "6")]
    pub bucket_limit: ::prost::alloc::vec::Vec<f64>,
    #[prost(double, repeated, tag = "7")]
    pub bucket: ::prost::alloc::vec::Vec<f64>,
}
/// Dimensions of a tensor.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorShapeProto {
    /// Dimensions of the tensor, such as {"input", 30}, {"output", 40}
    /// for a 30 x 40 2D tensor.  If an entry has size -1, this
    /// corresponds to a dimension of unknown size. The names are
    /// optional.
    ///
    /// The order of entries in "dim" matters: It indicates the layout of the
    /// values in the tensor in-memory representation.
    ///
    /// The first entry in "dim" is the outermost dimension used to layout the
    /// values, the last entry is the innermost dimension.  This matches the
    /// in-memory layout of RowMajor Eigen tensors.
    ///
    /// If "dim.size()" > 0, "unknown_rank" must be false.
    #[prost(message, repeated, tag = "2")]
    pub dim: ::prost::alloc::vec::Vec<tensor_shape_proto::Dim>,
    /// If true, the number of dimensions in the shape is unknown.
    ///
    /// If true, "dim.size()" must be 0.
    #[prost(bool, tag = "3")]
    pub unknown_rank: bool,
}
/// Nested message and enum types in `TensorShapeProto`.
pub mod tensor_shape_proto {
    /// One dimension of the tensor.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Dim {
        /// Size of the tensor in that dimension.
        /// This value must be >= -1, but values of -1 are reserved for "unknown"
        /// shapes (values of -1 mean "unknown" dimension).  Certain wrappers
        /// that work with TensorShapeProto may fail at runtime when deserializing
        /// a TensorShapeProto containing a dim value of -1.
        #[prost(int64, tag = "1")]
        pub size: i64,
        /// Optional name of the tensor dimension.
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
}
/// Represents a serialized tf.dtypes.Dtype
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SerializedDType {
    #[prost(enumeration = "DataType", tag = "1")]
    pub datatype: i32,
}
/// (== suppress_warning documentation-presence ==)
/// DISABLED.IfChange
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataType {
    /// Not a legal value for DataType.  Used to indicate a DataType field
    /// has not been set.
    DtInvalid = 0,
    /// Data types that all computation devices are expected to be
    /// capable to support.
    DtFloat = 1,
    DtDouble = 2,
    DtInt32 = 3,
    DtUint8 = 4,
    DtInt16 = 5,
    DtInt8 = 6,
    DtString = 7,
    /// Single-precision complex
    DtComplex64 = 8,
    DtInt64 = 9,
    DtBool = 10,
    /// Quantized int8
    DtQint8 = 11,
    /// Quantized uint8
    DtQuint8 = 12,
    /// Quantized int32
    DtQint32 = 13,
    /// Float32 truncated to 16 bits.
    DtBfloat16 = 14,
    /// Quantized int16
    DtQint16 = 15,
    /// Quantized uint16
    DtQuint16 = 16,
    DtUint16 = 17,
    /// Double-precision complex
    DtComplex128 = 18,
    DtHalf = 19,
    DtResource = 20,
    /// Arbitrary C++ data types
    DtVariant = 21,
    DtUint32 = 22,
    DtUint64 = 23,
    /// 5 exponent bits, 2 mantissa bits.
    DtFloat8E5m2 = 24,
    /// 4 exponent bits, 3 mantissa bits, finite-only, with
    DtFloat8E4m3fn = 25,
    /// 2 NaNs (0bS1111111).
    ///
    /// 4 exponent bits, 3 mantissa bits, finite-only,
    DtFloat8E4m3fnuz = 26,
    /// with NaN.
    ///
    /// 4 exponent bits, 3 mantissa bits, 11 bits
    DtFloat8E4m3b11fnuz = 27,
    /// bias, finite-only, with NaNs.
    ///
    /// 5 exponent bits, 2 mantissa bits, finite-only,
    DtFloat8E5m2fnuz = 28,
    DtInt4 = 29,
    DtUint4 = 30,
    /// Do not use!  These are only for TF1's obsolete reference Variables.
    /// Every enum above should have a corresponding value below (verified by
    /// types_test).
    DtFloatRef = 101,
    DtDoubleRef = 102,
    DtInt32Ref = 103,
    DtUint8Ref = 104,
    DtInt16Ref = 105,
    DtInt8Ref = 106,
    DtStringRef = 107,
    DtComplex64Ref = 108,
    DtInt64Ref = 109,
    DtBoolRef = 110,
    DtQint8Ref = 111,
    DtQuint8Ref = 112,
    DtQint32Ref = 113,
    DtBfloat16Ref = 114,
    DtQint16Ref = 115,
    DtQuint16Ref = 116,
    DtUint16Ref = 117,
    DtComplex128Ref = 118,
    DtHalfRef = 119,
    DtResourceRef = 120,
    DtVariantRef = 121,
    DtUint32Ref = 122,
    DtUint64Ref = 123,
    DtFloat8E5m2Ref = 124,
    DtFloat8E4m3fnRef = 125,
    DtFloat8E4m3fnuzRef = 126,
    DtFloat8E4m3b11fnuzRef = 127,
    DtFloat8E5m2fnuzRef = 128,
    DtInt4Ref = 129,
    DtUint4Ref = 130,
}
impl DataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DataType::DtInvalid => "DT_INVALID",
            DataType::DtFloat => "DT_FLOAT",
            DataType::DtDouble => "DT_DOUBLE",
            DataType::DtInt32 => "DT_INT32",
            DataType::DtUint8 => "DT_UINT8",
            DataType::DtInt16 => "DT_INT16",
            DataType::DtInt8 => "DT_INT8",
            DataType::DtString => "DT_STRING",
            DataType::DtComplex64 => "DT_COMPLEX64",
            DataType::DtInt64 => "DT_INT64",
            DataType::DtBool => "DT_BOOL",
            DataType::DtQint8 => "DT_QINT8",
            DataType::DtQuint8 => "DT_QUINT8",
            DataType::DtQint32 => "DT_QINT32",
            DataType::DtBfloat16 => "DT_BFLOAT16",
            DataType::DtQint16 => "DT_QINT16",
            DataType::DtQuint16 => "DT_QUINT16",
            DataType::DtUint16 => "DT_UINT16",
            DataType::DtComplex128 => "DT_COMPLEX128",
            DataType::DtHalf => "DT_HALF",
            DataType::DtResource => "DT_RESOURCE",
            DataType::DtVariant => "DT_VARIANT",
            DataType::DtUint32 => "DT_UINT32",
            DataType::DtUint64 => "DT_UINT64",
            DataType::DtFloat8E5m2 => "DT_FLOAT8_E5M2",
            DataType::DtFloat8E4m3fn => "DT_FLOAT8_E4M3FN",
            DataType::DtFloat8E4m3fnuz => "DT_FLOAT8_E4M3FNUZ",
            DataType::DtFloat8E4m3b11fnuz => "DT_FLOAT8_E4M3B11FNUZ",
            DataType::DtFloat8E5m2fnuz => "DT_FLOAT8_E5M2FNUZ",
            DataType::DtInt4 => "DT_INT4",
            DataType::DtUint4 => "DT_UINT4",
            DataType::DtFloatRef => "DT_FLOAT_REF",
            DataType::DtDoubleRef => "DT_DOUBLE_REF",
            DataType::DtInt32Ref => "DT_INT32_REF",
            DataType::DtUint8Ref => "DT_UINT8_REF",
            DataType::DtInt16Ref => "DT_INT16_REF",
            DataType::DtInt8Ref => "DT_INT8_REF",
            DataType::DtStringRef => "DT_STRING_REF",
            DataType::DtComplex64Ref => "DT_COMPLEX64_REF",
            DataType::DtInt64Ref => "DT_INT64_REF",
            DataType::DtBoolRef => "DT_BOOL_REF",
            DataType::DtQint8Ref => "DT_QINT8_REF",
            DataType::DtQuint8Ref => "DT_QUINT8_REF",
            DataType::DtQint32Ref => "DT_QINT32_REF",
            DataType::DtBfloat16Ref => "DT_BFLOAT16_REF",
            DataType::DtQint16Ref => "DT_QINT16_REF",
            DataType::DtQuint16Ref => "DT_QUINT16_REF",
            DataType::DtUint16Ref => "DT_UINT16_REF",
            DataType::DtComplex128Ref => "DT_COMPLEX128_REF",
            DataType::DtHalfRef => "DT_HALF_REF",
            DataType::DtResourceRef => "DT_RESOURCE_REF",
            DataType::DtVariantRef => "DT_VARIANT_REF",
            DataType::DtUint32Ref => "DT_UINT32_REF",
            DataType::DtUint64Ref => "DT_UINT64_REF",
            DataType::DtFloat8E5m2Ref => "DT_FLOAT8_E5M2_REF",
            DataType::DtFloat8E4m3fnRef => "DT_FLOAT8_E4M3FN_REF",
            DataType::DtFloat8E4m3fnuzRef => "DT_FLOAT8_E4M3FNUZ_REF",
            DataType::DtFloat8E4m3b11fnuzRef => "DT_FLOAT8_E4M3B11FNUZ_REF",
            DataType::DtFloat8E5m2fnuzRef => "DT_FLOAT8_E5M2FNUZ_REF",
            DataType::DtInt4Ref => "DT_INT4_REF",
            DataType::DtUint4Ref => "DT_UINT4_REF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DT_INVALID" => Some(Self::DtInvalid),
            "DT_FLOAT" => Some(Self::DtFloat),
            "DT_DOUBLE" => Some(Self::DtDouble),
            "DT_INT32" => Some(Self::DtInt32),
            "DT_UINT8" => Some(Self::DtUint8),
            "DT_INT16" => Some(Self::DtInt16),
            "DT_INT8" => Some(Self::DtInt8),
            "DT_STRING" => Some(Self::DtString),
            "DT_COMPLEX64" => Some(Self::DtComplex64),
            "DT_INT64" => Some(Self::DtInt64),
            "DT_BOOL" => Some(Self::DtBool),
            "DT_QINT8" => Some(Self::DtQint8),
            "DT_QUINT8" => Some(Self::DtQuint8),
            "DT_QINT32" => Some(Self::DtQint32),
            "DT_BFLOAT16" => Some(Self::DtBfloat16),
            "DT_QINT16" => Some(Self::DtQint16),
            "DT_QUINT16" => Some(Self::DtQuint16),
            "DT_UINT16" => Some(Self::DtUint16),
            "DT_COMPLEX128" => Some(Self::DtComplex128),
            "DT_HALF" => Some(Self::DtHalf),
            "DT_RESOURCE" => Some(Self::DtResource),
            "DT_VARIANT" => Some(Self::DtVariant),
            "DT_UINT32" => Some(Self::DtUint32),
            "DT_UINT64" => Some(Self::DtUint64),
            "DT_FLOAT8_E5M2" => Some(Self::DtFloat8E5m2),
            "DT_FLOAT8_E4M3FN" => Some(Self::DtFloat8E4m3fn),
            "DT_FLOAT8_E4M3FNUZ" => Some(Self::DtFloat8E4m3fnuz),
            "DT_FLOAT8_E4M3B11FNUZ" => Some(Self::DtFloat8E4m3b11fnuz),
            "DT_FLOAT8_E5M2FNUZ" => Some(Self::DtFloat8E5m2fnuz),
            "DT_INT4" => Some(Self::DtInt4),
            "DT_UINT4" => Some(Self::DtUint4),
            "DT_FLOAT_REF" => Some(Self::DtFloatRef),
            "DT_DOUBLE_REF" => Some(Self::DtDoubleRef),
            "DT_INT32_REF" => Some(Self::DtInt32Ref),
            "DT_UINT8_REF" => Some(Self::DtUint8Ref),
            "DT_INT16_REF" => Some(Self::DtInt16Ref),
            "DT_INT8_REF" => Some(Self::DtInt8Ref),
            "DT_STRING_REF" => Some(Self::DtStringRef),
            "DT_COMPLEX64_REF" => Some(Self::DtComplex64Ref),
            "DT_INT64_REF" => Some(Self::DtInt64Ref),
            "DT_BOOL_REF" => Some(Self::DtBoolRef),
            "DT_QINT8_REF" => Some(Self::DtQint8Ref),
            "DT_QUINT8_REF" => Some(Self::DtQuint8Ref),
            "DT_QINT32_REF" => Some(Self::DtQint32Ref),
            "DT_BFLOAT16_REF" => Some(Self::DtBfloat16Ref),
            "DT_QINT16_REF" => Some(Self::DtQint16Ref),
            "DT_QUINT16_REF" => Some(Self::DtQuint16Ref),
            "DT_UINT16_REF" => Some(Self::DtUint16Ref),
            "DT_COMPLEX128_REF" => Some(Self::DtComplex128Ref),
            "DT_HALF_REF" => Some(Self::DtHalfRef),
            "DT_RESOURCE_REF" => Some(Self::DtResourceRef),
            "DT_VARIANT_REF" => Some(Self::DtVariantRef),
            "DT_UINT32_REF" => Some(Self::DtUint32Ref),
            "DT_UINT64_REF" => Some(Self::DtUint64Ref),
            "DT_FLOAT8_E5M2_REF" => Some(Self::DtFloat8E5m2Ref),
            "DT_FLOAT8_E4M3FN_REF" => Some(Self::DtFloat8E4m3fnRef),
            "DT_FLOAT8_E4M3FNUZ_REF" => Some(Self::DtFloat8E4m3fnuzRef),
            "DT_FLOAT8_E4M3B11FNUZ_REF" => Some(Self::DtFloat8E4m3b11fnuzRef),
            "DT_FLOAT8_E5M2FNUZ_REF" => Some(Self::DtFloat8E5m2fnuzRef),
            "DT_INT4_REF" => Some(Self::DtInt4Ref),
            "DT_UINT4_REF" => Some(Self::DtUint4Ref),
            _ => None,
        }
    }
}
/// Protocol buffer representing a handle to a tensorflow resource. Handles are
/// not valid across executions, but can be serialized back and forth from within
/// a single run.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceHandleProto {
    /// Unique name for the device containing the resource.
    #[prost(string, tag = "1")]
    pub device: ::prost::alloc::string::String,
    /// Container in which this resource is placed.
    #[prost(string, tag = "2")]
    pub container: ::prost::alloc::string::String,
    /// Unique name of this resource.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Hash code for the type of the resource. Is only valid in the same device
    /// and in the same execution.
    #[prost(uint64, tag = "4")]
    pub hash_code: u64,
    /// For debug-only, the name of the type pointed to by this handle, if
    /// available.
    #[prost(string, tag = "5")]
    pub maybe_type_name: ::prost::alloc::string::String,
    /// Data types and shapes for the underlying resource.
    #[prost(message, repeated, tag = "6")]
    pub dtypes_and_shapes: ::prost::alloc::vec::Vec<resource_handle_proto::DtypeAndShape>,
}
/// Nested message and enum types in `ResourceHandleProto`.
pub mod resource_handle_proto {
    /// Protocol buffer representing a pair of (data type, tensor shape).
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DtypeAndShape {
        /// Data type of the tensor.
        #[prost(enumeration = "super::DataType", tag = "1")]
        pub dtype: i32,
        /// Shape of the tensor.
        #[prost(message, optional, tag = "2")]
        pub shape: ::core::option::Option<super::TensorShapeProto>,
    }
}
/// Protocol buffer representing a tensor.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorProto {
    /// Data type of the tensor.
    #[prost(enumeration = "DataType", tag = "1")]
    pub dtype: i32,
    /// Shape of the tensor.  TODO(touts): sort out the 0-rank issues.
    #[prost(message, optional, tag = "2")]
    pub tensor_shape: ::core::option::Option<TensorShapeProto>,
    /// Version number.
    ///
    /// In version 0, if the "repeated xxx" representations contain only one
    /// element, that element is repeated to fill the shape.  This makes it easy
    /// to represent a constant Tensor with a single value.
    #[prost(int32, tag = "3")]
    pub version_number: i32,
    /// Serialized raw tensor content from either Tensor::AsProtoTensorContent or
    /// memcpy in tensorflow::grpc::EncodeTensorToByteBuffer. This representation
    /// can be used for all tensor types. The purpose of this representation is to
    /// reduce serialization overhead during RPC call by avoiding serialization of
    /// many repeated small items.
    #[prost(bytes = "vec", tag = "4")]
    pub tensor_content: ::prost::alloc::vec::Vec<u8>,
    /// DT_HALF, DT_BFLOAT16. Note that since protobuf has no int16 type, we'll
    /// have some pointless zero padding for each value here.
    #[prost(int32, repeated, tag = "13")]
    pub half_val: ::prost::alloc::vec::Vec<i32>,
    /// DT_FLOAT.
    #[prost(float, repeated, tag = "5")]
    pub float_val: ::prost::alloc::vec::Vec<f32>,
    /// DT_DOUBLE.
    #[prost(double, repeated, tag = "6")]
    pub double_val: ::prost::alloc::vec::Vec<f64>,
    /// DT_INT32, DT_INT16, DT_UINT16, DT_INT8, DT_UINT8.
    #[prost(int32, repeated, tag = "7")]
    pub int_val: ::prost::alloc::vec::Vec<i32>,
    /// DT_STRING
    #[prost(bytes = "vec", repeated, tag = "8")]
    pub string_val: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real
    /// and imaginary parts of i-th single precision complex.
    #[prost(float, repeated, tag = "9")]
    pub scomplex_val: ::prost::alloc::vec::Vec<f32>,
    /// DT_INT64
    #[prost(int64, repeated, tag = "10")]
    pub int64_val: ::prost::alloc::vec::Vec<i64>,
    /// DT_BOOL
    #[prost(bool, repeated, tag = "11")]
    pub bool_val: ::prost::alloc::vec::Vec<bool>,
    /// DT_COMPLEX128. dcomplex_val(2*i) and dcomplex_val(2*i+1) are real
    /// and imaginary parts of i-th double precision complex.
    #[prost(double, repeated, tag = "12")]
    pub dcomplex_val: ::prost::alloc::vec::Vec<f64>,
    /// DT_RESOURCE
    #[prost(message, repeated, tag = "14")]
    pub resource_handle_val: ::prost::alloc::vec::Vec<ResourceHandleProto>,
    /// DT_VARIANT
    #[prost(message, repeated, tag = "15")]
    pub variant_val: ::prost::alloc::vec::Vec<VariantTensorDataProto>,
    /// DT_UINT32
    #[prost(uint32, repeated, tag = "16")]
    pub uint32_val: ::prost::alloc::vec::Vec<u32>,
    /// DT_UINT64
    #[prost(uint64, repeated, tag = "17")]
    pub uint64_val: ::prost::alloc::vec::Vec<u64>,
    /// DT_FLOAT8_*, use variable-sized set of bytes
    /// (i.e. the equivalent of repeated uint8, if such a thing existed).
    #[prost(bytes = "vec", tag = "18")]
    pub float8_val: ::prost::alloc::vec::Vec<u8>,
}
/// Protocol buffer representing the serialization format of DT_VARIANT tensors.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariantTensorDataProto {
    /// Name of the type of objects being serialized.
    #[prost(string, tag = "1")]
    pub type_name: ::prost::alloc::string::String,
    /// Portions of the object that are not Tensors.
    #[prost(bytes = "vec", tag = "2")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
    /// Tensors contained within objects being serialized.
    #[prost(message, repeated, tag = "3")]
    pub tensors: ::prost::alloc::vec::Vec<TensorProto>,
}
/// Metadata associated with a series of Summary data
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummaryDescription {
    /// Hint on how plugins should process the data in this series.
    /// Supported values include "scalar", "histogram", "image", "audio"
    #[prost(string, tag = "1")]
    pub type_hint: ::prost::alloc::string::String,
}
/// A SummaryMetadata encapsulates information on which plugins are able to make
/// use of a certain summary value.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummaryMetadata {
    /// Data that associates a summary with a certain plugin.
    #[prost(message, optional, tag = "1")]
    pub plugin_data: ::core::option::Option<summary_metadata::PluginData>,
    /// Display name for viewing in TensorBoard.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Longform readable description of the summary sequence. Markdown supported.
    #[prost(string, tag = "3")]
    pub summary_description: ::prost::alloc::string::String,
    /// Class of data stored in this time series. Required for compatibility with
    /// TensorBoard's generic data facilities (`DataProvider`, et al.). This value
    /// imposes constraints on the dtype and shape of the corresponding tensor
    /// values. See `DataClass` docs for details.
    #[prost(enumeration = "DataClass", tag = "4")]
    pub data_class: i32,
}
/// Nested message and enum types in `SummaryMetadata`.
pub mod summary_metadata {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PluginData {
        /// The name of the plugin this data pertains to.
        #[prost(string, tag = "1")]
        pub plugin_name: ::prost::alloc::string::String,
        /// The content to store for the plugin. The best practice is for this to be
        /// a binary serialized protocol buffer.
        #[prost(bytes = "vec", tag = "2")]
        pub content: ::prost::alloc::vec::Vec<u8>,
    }
}
/// A Summary is a set of named values to be displayed by the
/// visualizer.
///
/// Summaries are produced regularly during training, as controlled by
/// the "summary_interval_secs" attribute of the training operation.
/// Summaries are also produced at the end of an evaluation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Summary {
    /// Set of values for the summary.
    #[prost(message, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<summary::Value>,
}
/// Nested message and enum types in `Summary`.
pub mod summary {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Image {
        /// Dimensions of the image.
        #[prost(int32, tag = "1")]
        pub height: i32,
        #[prost(int32, tag = "2")]
        pub width: i32,
        /// Valid colorspace values are
        ///    1 - grayscale
        ///    2 - grayscale + alpha
        ///    3 - RGB
        ///    4 - RGBA
        ///    5 - DIGITAL_YUV
        ///    6 - BGRA
        #[prost(int32, tag = "3")]
        pub colorspace: i32,
        /// Image data in encoded format.  All image formats supported by
        /// image_codec::CoderUtil can be stored here.
        #[prost(bytes = "vec", tag = "4")]
        pub encoded_image_string: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Audio {
        /// Sample rate of the audio in Hz.
        #[prost(float, tag = "1")]
        pub sample_rate: f32,
        /// Number of channels of audio.
        #[prost(int64, tag = "2")]
        pub num_channels: i64,
        /// Length of the audio in frames (samples per channel).
        #[prost(int64, tag = "3")]
        pub length_frames: i64,
        /// Encoded audio data and its associated RFC 2045 content type (e.g.
        /// "audio/wav").
        #[prost(bytes = "vec", tag = "4")]
        pub encoded_audio_string: ::prost::alloc::vec::Vec<u8>,
        #[prost(string, tag = "5")]
        pub content_type: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Value {
        /// This field is deprecated and will not be set.
        #[prost(string, tag = "7")]
        pub node_name: ::prost::alloc::string::String,
        /// Tag name for the data. Used by TensorBoard plugins to organize data. Tags
        /// are often organized by scope (which contains slashes to convey
        /// hierarchy). For example: foo/bar/0
        #[prost(string, tag = "1")]
        pub tag: ::prost::alloc::string::String,
        /// Contains metadata on the summary value such as which plugins may use it.
        /// Take note that many summary values may lack a metadata field. This is
        /// because the FileWriter only keeps a metadata object on the first summary
        /// value with a certain tag for each tag. TensorBoard then remembers which
        /// tags are associated with which plugins. This saves space.
        #[prost(message, optional, tag = "9")]
        pub metadata: ::core::option::Option<super::SummaryMetadata>,
        /// Value associated with the tag.
        #[prost(oneof = "value::Value", tags = "2, 3, 4, 5, 6, 8")]
        pub value: ::core::option::Option<value::Value>,
    }
    /// Nested message and enum types in `Value`.
    pub mod value {
        /// Value associated with the tag.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(float, tag = "2")]
            Simple(f32),
            #[prost(bytes, tag = "3")]
            ObsoleteOldStyleHistogram(::prost::alloc::vec::Vec<u8>),
            #[prost(message, tag = "4")]
            Image(super::Image),
            #[prost(message, tag = "5")]
            Histo(super::super::HistogramProto),
            #[prost(message, tag = "6")]
            Audio(super::Audio),
            #[prost(message, tag = "8")]
            Tensor(Box<super::super::TensorProto>), // Boxed to reduce enum size
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataClass {
    /// Unknown data class, used (implicitly) for legacy data. Will not be
    /// processed by data ingestion pipelines.
    Unknown = 0,
    /// Scalar time series. Each `Value` for the corresponding tag must have
    /// `tensor` set to a rank-0 tensor of type `DT_FLOAT` (float32).
    Scalar = 1,
    /// Tensor time series. Each `Value` for the corresponding tag must have
    /// `tensor` set. The tensor value is arbitrary, but should be small to
    /// accommodate direct storage in database backends: an upper bound of a few
    /// kilobytes is a reasonable rule of thumb.
    Tensor = 2,
    /// Blob sequence time series. Each `Value` for the corresponding tag must
    /// have `tensor` set to a rank-1 tensor of bytestring dtype.
    BlobSequence = 3,
}
impl DataClass {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DataClass::Unknown => "DATA_CLASS_UNKNOWN",
            DataClass::Scalar => "DATA_CLASS_SCALAR",
            DataClass::Tensor => "DATA_CLASS_TENSOR",
            DataClass::BlobSequence => "DATA_CLASS_BLOB_SEQUENCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_CLASS_UNKNOWN" => Some(Self::Unknown),
            "DATA_CLASS_SCALAR" => Some(Self::Scalar),
            "DATA_CLASS_TENSOR" => Some(Self::Tensor),
            "DATA_CLASS_BLOB_SEQUENCE" => Some(Self::BlobSequence),
            _ => None,
        }
    }
}
/// Protocol buffer representing an event that happened during
/// the execution of a Brain model.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Timestamp of the event.
    #[prost(double, tag = "1")]
    pub wall_time: f64,
    /// Global step of the event.
    #[prost(int64, tag = "2")]
    pub step: i64,
    /// Information of the source that writes the events, this is only logged in
    /// the very first event along with the `file_version` field.
    #[prost(message, optional, tag = "10")]
    pub source_metadata: ::core::option::Option<SourceMetadata>,
    #[prost(oneof = "event::What", tags = "3, 4, 5, 6, 7, 8, 9")]
    pub what: ::core::option::Option<event::What>,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum What {
        /// An event file was started, with the specified version.
        /// This is use to identify the contents of the record IO files
        /// easily.  Current version is "brain.Event:2".  All versions
        /// start with "brain.Event:".
        #[prost(string, tag = "3")]
        FileVersion(::prost::alloc::string::String),
        /// An encoded version of a GraphDef.
        #[prost(bytes, tag = "4")]
        GraphDef(::prost::alloc::vec::Vec<u8>),
        /// A summary was generated.
        #[prost(message, tag = "5")]
        Summary(super::Summary),
        /// The user output a log message. This was theoretically used by the defunct
        /// tensorboard_logging module, which has since been removed; this field is
        /// now deprecated and should not be used.
        #[prost(message, tag = "6")]
        LogMessage(super::LogMessage),
        /// The state of the session which can be used for restarting after crashes.
        #[prost(message, tag = "7")]
        SessionLog(super::SessionLog),
        /// The metadata returned by running a session.run() call.
        #[prost(message, tag = "8")]
        TaggedRunMetadata(super::TaggedRunMetadata),
        /// An encoded version of a MetaGraphDef.
        #[prost(bytes, tag = "9")]
        MetaGraphDef(::prost::alloc::vec::Vec<u8>),
    }
}
/// Holds the information of the source that writes the events.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceMetadata {
    /// Low level name of the summary writer, such as
    /// `tensorflow.core.util.events_writer`.
    #[prost(string, tag = "1")]
    pub writer: ::prost::alloc::string::String,
}
/// Protocol buffer used for logging messages to the events file.
///
/// This was theoretically used by the defunct tensorboard_logging module, which
/// has been removed; this message is now deprecated and should not be used.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogMessage {
    #[prost(enumeration = "log_message::Level", tag = "1")]
    pub level: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LogMessage`.
pub mod log_message {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Level {
        Unknown = 0,
        /// Note: The logging level 10 cannot be named DEBUG. Some software
        /// projects compile their C/C++ code with -DDEBUG in debug builds. So the
        /// C++ code generated from this file should not have an identifier named
        /// DEBUG.
        Debugging = 10,
        Info = 20,
        Warn = 30,
        Error = 40,
        Fatal = 50,
    }
    impl Level {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Level::Unknown => "UNKNOWN",
                Level::Debugging => "DEBUGGING",
                Level::Info => "INFO",
                Level::Warn => "WARN",
                Level::Error => "ERROR",
                Level::Fatal => "FATAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "DEBUGGING" => Some(Self::Debugging),
                "INFO" => Some(Self::Info),
                "WARN" => Some(Self::Warn),
                "ERROR" => Some(Self::Error),
                "FATAL" => Some(Self::Fatal),
                _ => None,
            }
        }
    }
}
/// Protocol buffer used for logging session state.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionLog {
    #[prost(enumeration = "session_log::SessionStatus", tag = "1")]
    pub status: i32,
    /// This checkpoint_path contains both the path and filename.
    #[prost(string, tag = "2")]
    pub checkpoint_path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub msg: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SessionLog`.
pub mod session_log {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SessionStatus {
        StatusUnspecified = 0,
        Start = 1,
        Stop = 2,
        Checkpoint = 3,
    }
    impl SessionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SessionStatus::StatusUnspecified => "STATUS_UNSPECIFIED",
                SessionStatus::Start => "START",
                SessionStatus::Stop => "STOP",
                SessionStatus::Checkpoint => "CHECKPOINT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::StatusUnspecified),
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                "CHECKPOINT" => Some(Self::Checkpoint),
                _ => None,
            }
        }
    }
}
/// For logging the metadata output for a single session.run() call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaggedRunMetadata {
    /// Tag name associated with this metadata.
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    /// Byte-encoded version of the `RunMetadata` proto in order to allow lazy
    /// deserialization.
    #[prost(bytes = "vec", tag = "2")]
    pub run_metadata: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchdogConfig {
    #[prost(int64, tag = "1")]
    pub timeout_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestedExitCode {
    #[prost(int32, tag = "1")]
    pub exit_code: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerHeartbeatRequest {
    #[prost(enumeration = "WorkerShutdownMode", tag = "1")]
    pub shutdown_mode: i32,
    #[prost(message, optional, tag = "2")]
    pub watchdog_config: ::core::option::Option<WatchdogConfig>,
    #[prost(message, optional, tag = "3")]
    pub exit_code: ::core::option::Option<RequestedExitCode>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerHeartbeatResponse {
    #[prost(enumeration = "WorkerHealth", tag = "1")]
    pub health_status: i32,
    #[prost(message, repeated, tag = "2")]
    pub worker_log: ::prost::alloc::vec::Vec<Event>,
    #[prost(string, tag = "3")]
    pub hostname: ::prost::alloc::string::String,
}
/// Current health status of a worker.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkerHealth {
    /// By default a worker is healthy.
    Ok = 0,
    ReceivedShutdownSignal = 1,
    InternalError = 2,
    /// Worker has been instructed to shutdown after a timeout.
    ShuttingDown = 3,
}
impl WorkerHealth {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkerHealth::Ok => "OK",
            WorkerHealth::ReceivedShutdownSignal => "RECEIVED_SHUTDOWN_SIGNAL",
            WorkerHealth::InternalError => "INTERNAL_ERROR",
            WorkerHealth::ShuttingDown => "SHUTTING_DOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OK" => Some(Self::Ok),
            "RECEIVED_SHUTDOWN_SIGNAL" => Some(Self::ReceivedShutdownSignal),
            "INTERNAL_ERROR" => Some(Self::InternalError),
            "SHUTTING_DOWN" => Some(Self::ShuttingDown),
            _ => None,
        }
    }
}
/// Indicates the behavior of the worker when an internal error or shutdown
/// signal is received.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkerShutdownMode {
    Default = 0,
    NotConfigured = 1,
    WaitForCoordinator = 2,
    ShutdownAfterTimeout = 3,
}
impl WorkerShutdownMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkerShutdownMode::Default => "DEFAULT",
            WorkerShutdownMode::NotConfigured => "NOT_CONFIGURED",
            WorkerShutdownMode::WaitForCoordinator => "WAIT_FOR_COORDINATOR",
            WorkerShutdownMode::ShutdownAfterTimeout => "SHUTDOWN_AFTER_TIMEOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT" => Some(Self::Default),
            "NOT_CONFIGURED" => Some(Self::NotConfigured),
            "WAIT_FOR_COORDINATOR" => Some(Self::WaitForCoordinator),
            "SHUTDOWN_AFTER_TIMEOUT" => Some(Self::ShutdownAfterTimeout),
            _ => None,
        }
    }
}
